"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const strip_json_comments_1 = tslib_1.__importDefault(require("strip-json-comments"));
class FileAnalyzer {
    /**
     * Builds the function body depending on the export
     */
    static buildExportBody(analyzedFile, e, newName, globalRenames) {
        let is = e.is;
        if (is) {
            globalRenames.forEach((i) => {
                is = is.replace(`${i.globalRename}.${i.name}`, `${i.globalRename}$${i.name}`);
            });
            analyzedFile.imports.forEach((i) => {
                if (i.namedImports) {
                    i.namedImports.forEach((ni) => {
                        if (ni.as) {
                            is = is.replace(ni.name, ni.as);
                        }
                    });
                }
            });
        }
        return `${e.type} ${newName || e.name} ${is}${e.body}`;
    }
    /**
     * Filename to read to get contract data
     */
    constructor(filename) {
        this.filename = filename;
    }
    /**
     * Returns imports and exports of the processing file
     */
    analyze() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield fs_extra_1.default.stat(this.filename);
            let contents = yield fs_extra_1.default.readFile(this.filename, { encoding: 'utf-8' });
            contents = strip_json_comments_1.default(contents, { whitespace: false });
            const imports = this.analyzeImports(contents);
            const exports = this.analyzeExports(contents);
            return {
                filename: this.filename,
                contents,
                imports,
                exports,
            };
        });
    }
    /**
     * Analyzes all the imports of the file
     */
    analyzeImports(contents) {
        const imports = [];
        const importRegex = /import .+?;/g;
        let group;
        while ((group = importRegex.exec(contents))) {
            const importStatement = group[0];
            const analyzedImport = this.analyzeImport(importStatement);
            imports.push(analyzedImport);
        }
        return imports;
    }
    /**
     * Single import statement to process. Basicly it analizes next things:
     *
     * 1. Rename of the global import if any
     * 2. Named imports if any
     * 3. Extract filename from import
     *
     */
    analyzeImport(importStatement) {
        const fileRegex = /['"](.+?)['"]/;
        const group = fileRegex.exec(importStatement);
        if (!group) {
            throw new Error('Unknown import statement');
        }
        const file = group[1];
        const globalRenameRegex = /.+\s+as\s+([a-zA-Z_$][a-zA-Z_$0-9]*);$|.+\*\s+as\s+([a-zA-Z_$][a-zA-Z_$0-9]*)\s+from.+;$/;
        const renameGroup = globalRenameRegex.exec(importStatement);
        const globalRenameImport = renameGroup && (renameGroup[1] || renameGroup[2]);
        const namedImportsRegex = /\{(.+)\}/;
        const namedImportsGroup = namedImportsRegex.exec(importStatement);
        const namedImports = namedImportsGroup &&
            namedImportsGroup[1].split(',').map((namedImport) => {
                if (namedImport.indexOf('as') !== -1) {
                    const [name, as] = namedImport.trim().split(/\s+as\s+/);
                    return {
                        name,
                        as,
                    };
                }
                return {
                    name: namedImport.trim(),
                    as: null,
                };
            });
        return {
            file,
            globalRenameImport,
            namedImports,
        };
    }
    /**
     * Analyzes all the exports of the file (Contract, Interface, Library)
     *
     * Single export statement to process. Basicly it analizes next things:
     *
     * 1. Get the type of the export
     * 2. Get the body of the export
     * 3. Get inheritance of the specifier
     *
     */
    analyzeExports(contents) {
        const exportRegex = /(contract|library|interface)\s+([a-zA-Z_$][a-zA-Z_$0-9]*)\s*([\s\S]*?)\{/g;
        const results = [];
        let group;
        while ((group = exportRegex.exec(contents))) {
            const [, type, name, is] = group;
            const body = this.findBodyEnd(contents, group.index + group[0].length - 1);
            results.push({
                type,
                name,
                is,
                body,
            });
        }
        return results;
    }
    /**
     * @param contents file contents
     * @param start start of the body, start must be pointing to "{"
     * @returns body of the export
     */
    findBodyEnd(contents, start) {
        let deep = 1;
        let idx = start + 1;
        let inString = false;
        let isSingleQuotedString = false;
        while (deep !== 0 && idx < contents.length) {
            if (contents[idx] === '}' && !inString) {
                deep -= 1;
            }
            if (contents[idx] === '{' && !inString) {
                deep += 1;
            }
            if (contents[idx] === '"') {
                if ((inString && contents[idx - 1] !== '\\' && !isSingleQuotedString) ||
                    !inString) {
                    isSingleQuotedString = false;
                    inString = !inString;
                }
            }
            if (contents[idx] === "'") {
                if ((inString && contents[idx - 1] !== '\\' && isSingleQuotedString) ||
                    !inString) {
                    isSingleQuotedString = true;
                    inString = !inString;
                }
            }
            idx += 1;
        }
        if (deep !== 0) {
            throw new Error('Export is not correct. Has more opening brackets then closing.');
        }
        return contents.substring(start, idx);
    }
}
exports.FileAnalyzer = FileAnalyzer;
//# sourceMappingURL=fileAnalyzer.js.map