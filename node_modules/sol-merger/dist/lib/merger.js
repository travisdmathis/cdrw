"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const child_process_1 = require("child_process");
const utils_1 = require("./utils");
const debug_1 = tslib_1.__importDefault(require("debug"));
const fileAnalyzer_1 = require("./fileAnalyzer");
const error = debug_1.default('sol-merger:error');
const log = debug_1.default('sol-merge:log');
class Merger {
    constructor(options = {}) {
        const { delimeter } = options;
        this.delimeter = delimeter || '\n\n';
        this.registeredImports = [];
        this.nodeModulesRoot = null;
    }
    getPragmaRegex() {
        return /(pragma ([a-zA-Z_$][a-zA-Z_$0-9]*) (.+?);)/g;
    }
    getImportRegex() {
        return /import.+?;/g;
    }
    getPragma(contents) {
        let result = '';
        const pragmaRegex = this.getPragmaRegex();
        let group = pragmaRegex.exec(contents);
        while (group) {
            result += group[1] + '\n';
            group = pragmaRegex.exec(contents);
        }
        return result;
    }
    stripPragma(contents) {
        return contents.replace(this.getPragmaRegex(), '').trim();
    }
    isImported(filename, name, as) {
        return (this.registeredImports.find((ri) => ri.file === filename && ri.name === name && ri.as === as) !== undefined // eslint-disable-line
        );
    }
    processFile(file, isRoot, parentImport) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (isRoot) {
                this.registeredImports = [];
                this.nodeModulesRoot = yield this.getNodeModulesPath(file);
            }
            const analyzedFile = yield new fileAnalyzer_1.FileAnalyzer(file).analyze();
            let result = '';
            if (isRoot) {
                const pragma = this.getPragma(analyzedFile.contents);
                result = pragma + this.delimeter;
            }
            const imports = yield this.processImports(analyzedFile);
            for (const i of imports) {
                result += i + this.delimeter;
            }
            const exports = yield this.processExports(analyzedFile, parentImport);
            for (const e of exports) {
                result += e + this.delimeter;
            }
            return result.trimRight();
        });
    }
    processImports(analyzedFile) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const i of analyzedFile.imports) {
                let filePath = utils_1.Utils.isRelative(i.file)
                    ? path_1.default.join(path_1.default.dirname(analyzedFile.filename), i.file)
                    : path_1.default.join(this.nodeModulesRoot, i.file);
                filePath = path_1.default.normalize(filePath);
                const contents = yield this.processFile(filePath, false, i);
                if (contents) {
                    result.push(contents);
                }
            }
            return result;
        });
    }
    processExports(analyzedFile, parentImport) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const isAllImport = utils_1.Utils.isAllImport(parentImport);
            const isRenameGlobalImport = utils_1.Utils.isRenameGlobalImport(parentImport);
            const shouldBeImported = (exportName) => {
                return (isAllImport ||
                    isRenameGlobalImport ||
                    parentImport.namedImports.find((namedImport) => namedImport.name === exportName));
            };
            const result = [];
            analyzedFile.exports.forEach((e) => {
                this.processExport(analyzedFile, parentImport, e, shouldBeImported, isRenameGlobalImport, result);
            });
            return result;
        });
    }
    processExport(analyzedFile, parentImport, e, shouldBeImported, isRenameGlobalImport, result) {
        const beImported = shouldBeImported(e.name);
        let rename = typeof beImported === 'object' && beImported !== null
            ? beImported.as
            : null;
        const isImported = this.isImported(analyzedFile.filename, e.name, rename);
        if (isImported) {
            log('%s %s %s', 'âš ', e.name, analyzedFile.filename);
            return;
        }
        if (beImported) {
            if (isRenameGlobalImport) {
                rename = `${parentImport.globalRenameImport}$${e.name}`;
            }
            const globalRenames = this.getGlobalImports();
            const body = fileAnalyzer_1.FileAnalyzer.buildExportBody(analyzedFile, e, rename, globalRenames);
            result.push(body);
            this.registerImport({
                as: rename,
                file: analyzedFile.filename,
                name: e.name,
                globalRename: parentImport && parentImport.globalRenameImport,
            });
        }
    }
    registerImport(i) {
        this.registeredImports.push(i);
    }
    getGlobalImports() {
        return this.registeredImports.filter((i) => i.globalRename);
    }
    stripImports(contents) {
        return contents.replace(this.getImportRegex(), '').trim();
    }
    getNodeModulesPath(file) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                child_process_1.exec('npm root', { cwd: path_1.default.dirname(file) }, (err, stdout) => {
                    if (err) {
                        error('Unable to find npm root directory. Make sure contract is inside npm package.');
                        return reject(err);
                    }
                    resolve(stdout.trim());
                });
            });
        });
    }
}
exports.Merger = Merger;
//# sourceMappingURL=merger.js.map